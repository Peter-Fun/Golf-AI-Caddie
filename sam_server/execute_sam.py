"""
author: Peter Xiao
email: peterxiaofun@gmail.com
date: 2024-09-09
"""


import json
import base64
import uuid
import numpy as np
import cv2
import os
import json
import requests
from typing import List, Dict, Tuple


"""
Utility functions to call the SAM API server. The server was adapted from:
    https://github.com/ksugar/samapi/tree/main?tab=readme-ov-file#endpoint-samautomask-post

Our project modifies the server parameters to optimize golf map segmentation.
"""


SAM_API_ADDR = "https://<fill-w-perm-ngrok-addr>.ngrok-free.app/sam/"
TEST_FILE = "samapi/clickfiles/icreek1.json"


def get_samapi_version() -> str:
    """
    Return the samapi server package version. Also, can be used to check if server is connected.

    Returns:
        version_str: a string indiciating the SAM API version.
    """
    result = requests.get(SAM_API_ADDR + "version/")
    return result.text


def call_sam(b64str_img: str) -> str:
    """
    Utility function to call the SAM server at the SAM_API_ADDR. The SAM server will inference the
    SAM model to generate GeoJSON edges to capture segmented regions within the image.

    This function tunes the SAM parameters to work best with golf map segmentation. Specifically,
    this call makes a POST request to /sam/automask/ and waits for a response.

    The SAM parameters are described here:
        https://github.com/ksugar/samapi/tree/main?tab=readme-ov-file#endpoint-samautomask-post
    
    Args:
        b64str_img: an image encoded as an base64 character string.

    Returns:
        sam_segmentation: a geojson string that outlines the edges of the segmentations. The geojson
            contains a list of json objects with following keys: "geometry", "type", and
            "properties". 
    """
    result = requests.post(
        SAM_API_ADDR + "automask/",
        json={
            "type": "sam2_l",
            "b64img": b64str_img,
            "output_type": "Multi-mask (all)",
            "pred_iou_thresh": 0.8, # Default 0.88
            "points_per_side": 100, # Default 32
            "points_per_batch": 128, # Default 64
        }
    )
    return result.text


def calculate_center_of_mass(vertices: List[Tuple[float,float]]) -> Tuple[float,float]:
    """
    Calculate the center of mass using the shoelace formula. 

    Args:
        verticies: a list of sequential verticies (u,v) describing a n-gon.
    
    Returns:
        com: the (u,v) of the center of mass of the shape.
    """
    n = len(vertices)
    # Ensure there are enough vertices
    if n < 3:
        raise ValueError("A polygon must have at least 3 vertices.")
    
    # Initialize variables for area and centroid calculation
    area = 0.0
    cx = 0.0
    cy = 0.0

    # Calculate area using the shoelace formula
    for i in range(n):
        x0, y0 = vertices[i]
        x1, y1 = vertices[(i + 1) % n]  # Next vertex, wrapping around
        cross_product = x0 * y1 - x1 * y0
        area += cross_product
        cx += (x0 + x1) * cross_product
        cy += (y0 + y1) * cross_product
    
    area *= 0.5
    if area == 0:
        raise ValueError("The area of the polygon is zero, check the vertices.")
    
    # Finalize centroid coordinates
    cx /= (6 * area)
    cy /= (6 * area)

    return (round(cx,4), round(cy,4))


def analyze_result(geojson_str: str, clicks: Dict) -> List[Dict]:
    """
    Analyse geojson string generated by the samapi.

    Args:
        geojson_str: the geojson string. Contains a list of json objects with following keys: 
            "geometry", "type", and "properties". 

    Returns:
        bounding_boxes: a list of bounding boxes. Each bounding box is a dictionary with describing
            the locations of the box corners and center.
    """
    data = json.loads(geojson_str)
    all_metrics = []
    for golf_feature in clicks.keys():
        if golf_feature != "file" and golf_feature != "scale":
            for click in clicks[golf_feature]:
                minarea = -1
                click["u"] *= clicks["scale"]
                click["v"] *= clicks["scale"]
                for feature in data:  # feature contains 'type', 'geometry', and 'properties'
                    verticies = feature['geometry']['coordinates'][0]
                    verticies = np.array(verticies) * clicks["scale"]
                    
                    # Calculate the edges of the bounding box.
                    u0, v0 = np.min(verticies, axis=0)
                    u1, v1 = np.max(verticies, axis=0)
                    if contained(u0, v0, u1, v1, click):
                        if minarea == -1 or abs(u1 - u0) * abs(v1-v0) < minarea:
                            minarea = abs(u1 - u0) * abs(v1-v0)
                            feature_info = {
                                "feature_name" : golf_feature,
                                "feature_center_yards" : calculate_center_of_mass(verticies),
                                "coordinates" : [u0,v0,u1,v1]
                            } # add distance and direction to other features
                            if golf_feature == "tee":
                                feature_info["tee_color"] = click["color"]
                
                all_metrics.append(feature_info)
    return all_metrics


def contained(u0: float, v0: float, u1: float, v1: float, click: Dict) -> bool:
    """
    Determine whether a 2d click coordinate is located within a 2d bounding box.

    Args:
        u0: the u coordinate of the top left corner (u0,v0) of the bbox.
        v0: the v coordinate of the top left corner (u0,v0) of the bbox.
        u1: the u coordinate of the bot right corner (u1,v1) of the bbox.
        v1: the v coordinate of the bot right corner (u1,v1) of the bbox.
        click: the (u,v) coordinates of a specific point or "click"

    Returns:
        within: returns whether the click was within the bounding box described.
    """
    if u0 <= click["u"] and u1 >= click["u"] and v0 <= click["v"] and v1 >= click["v"]:
        return True
    else:
        return False


def feature_analysis(metrics: Dict) -> List[Dict]:
    """
    Given metrics about golf features analyze various characteristics of how they're related
    """
    # json.dumps 
    # keep things more structured (keep the scale)
    # go shot by shot instead of a whole plan at once

    # calculate distance from tee to middle of fairway, tee to bunker
    print("Distance from fairway to bunkers and green")
    fairway_bunker = []
    fairway_green = []
    tee_fairway = []
    tee_bunker = []
    for fairway in metrics["fairway"]:
        for bunker in metrics["bunker"]:
            distance = round(((fairway['feature_center_yards'][0] - bunker["feature_center_yards"][0]) ** 2 + (fairway['feature_center_yards'][1] - bunker["feature_center_yards"][1]) ** 2) ** 0.5,2)
            fairway_bunker.append({
                "distance" : distance,
                "feature_1" : fairway,
                "feature_2" : bunker
            })
        for green in metrics["green"]:
            distance = round(((fairway['feature_center_yards'][0] - green["feature_center_yards"][0]) ** 2 + (fairway['feature_center_yards'][1] - green["feature_center_yards"][1]) ** 2) ** 0.5,2)
            fairway_green.append({
                "distance" : distance,
                "feature_1" : fairway,
                "feature_2" : green
            })
        for tee in metrics["tee"]:
            distance = round(((fairway['feature_center_yards'][0] - tee["feature_center_yards"][0]) ** 2 + (fairway['feature_center_yards'][1] - tee["feature_center_yards"][1]) ** 2) ** 0.5,2)
            fairway_green.append({
                    "distance" : distance,
                    "feature_1" : tee,
                    "feature_2" : fairway
                })
    for tee in metrics["tee"]:
        for bunker in metrics["bunker"]:
            distance = round(((tee['feature_center_yards'][0] - bunker["feature_center_yards"][0]) ** 2 + (bunker['feature_center_yards'][1] - tee["feature_center_yards"][1]) ** 2) ** 0.5,2)
            tee_bunker.append({
                    "distance" : distance,
                    "feature_1" : tee,
                    "feature_2" : bunker
                })
    
    return fairway_bunker + fairway_green +tee_fairway + tee_bunker


def feature_organization(metrics: List[Dict]) -> Dict:
    """
    Given metrics about polygons mapped to golf features return a dictionary of golf features mapped to polygons
    """
    features = {}
    for metric in metrics:
        try:
            features[metric["feature_name"]].append(metric)
        except:
            features[metric["feature_name"]] = [metric]
    return features


def visualize_detections(metrics: Dict, in_img_file: str, out_img_file: str) -> None:
    """
    Visualize the detected bounding boxes and centers of mass within the golf map image. This method
    will draw on top of the original image using opencv functions to indicate SAM outputs and 
    analysis.

    Args:
        metrics: the metrics outputed by feature_analysis function.
        in_img_file: the input image to load and draw over.
        out_img_file: where to save the annotated image.
    """
    im = cv2.imread(in_img_file)
    for feature_type in metrics.keys():  # "bunker", "fairway", "green", "tee"
        for feature_info in metrics[feature_type]:
            u0, v0, u1, v1 = feature_info["coordinates"]
            uc, vc = feature_info["feature_center_yards"]
            # Draw the bounding box
            cv2.rectangle(im, (int(u0), int(v0)), (int(u1), int(v1)), (255,0,0), 2)
            # Label the detected class [bunker fairway green tee]
            cv2.putText(
                im, feature_type, (int(u0), int(v0) - 10), fontFace = cv2.FONT_HERSHEY_SIMPLEX, 
                fontScale=0.6, color=(255,0,0)
            )
            # Label the center of mass as a point.
            cv2.circle(im, (int(uc), int(vc)), radius=4, color=(255,0,0), thickness=-1)
    cv2.imwrite(out_img_file, im)  # write to file.


def setup_info():
    """
    Return information about the user's available clubs and expected performance.
    """
    setup_info = {
        "avilable_clubs" : ["driver", "7-iron", "5-hybrid", "5-iron", "sand wedge", "putter"],
        "club_performance" : {
            "driver" : 270, 
            "7-iron" : 140, 
            "5-hybrid" : 200, 
            "5-iron" : 160, 
            "pitching wedge": 90,
            "sand wedge" : 40,
        },
        "level_error" : 20,
        "tee_color" : "black"
    }
    return setup_info


def form_llm_input_using_sam(clicks_data: Dict, debug: bool = False) -> str:
    """
    Form the input to the LLM call using SAM to analyze the input image.
    """

    file_dir = os.path.dirname(os.path.realpath('__file__'))

    # Read the test image.
    input_img = os.path.join(file_dir, clicks_data["file"])
    with open(os.path.join(file_dir, clicks_data["file"]), "rb") as image_file:
        b64str_img = base64.b64encode(image_file.read()).decode("utf-8")
    
    # Pass the test image.
    sam_response: str = call_sam(b64str_img,[])

    # Form the input string.
    input_str = ""
    input_str += "The following are the 3 input parts described previously:\n"
    input_str += "## Setup Information\n"
    input_str += json.dumps(setup_info(), indent=4) + "\n"
    metrics = analyze_result(sam_response, clicks_data)
    input_str += "## Physical Features\n"
    input_str += json.dumps(metrics, indent=4)
    metrics = feature_organization(metrics) # Physical Features

    # For debugging using visualizations.
    if debug:
        output_img = os.path.join(file_dir, str(uuid.uuid4()) + ".jpg")
        visualize_detections(metrics, input_img, output_img)

    metrics = feature_analysis(metrics)
    input_str += "## Inter-Feature Distance\n"
    input_str += json.dumps(metrics, indent=4) + "\n"
    
    return input_str


def test_sam_service():
    """
    Function to test the SAM API for functionality. This wills end a sample image and 
    return the result.
    """
    file_dir = os.path.dirname(os.path.realpath('__file__'))
    # Read the test image.
    with open(os.path.join(file_dir, TEST_FILE), "r") as file:
        data = json.load(file)
    input_img = os.path.join(file_dir, data["file"])
    output_img = os.path.join(file_dir, str(uuid.uuid4()) + ".jpg")
    with open(os.path.join(file_dir, data["file"]), "rb") as image_file:
        b64str_img = base64.b64encode(image_file.read()).decode("utf-8")
    
    # Pass the test image.
    sam_response: str = call_sam(b64str_img,[])
    
    with open("input.txt","w") as file:
        file.write("The following are the 3 input parts described previously:\n")
    with open("input.txt","a") as file:
        file.write("## Setup Information\n")
        file.write(json.dumps(setup_info(),indent = 4) + "\n")
    # Compute analysis on the GeoJSON result.
    metrics = analyze_result(sam_response, data) # Physical Features
    with open("input.txt","a") as file:
        file.write("## Physical Features\n")
        file.write(json.dumps(metrics,indent = 4)+ "\n")
    metrics = feature_organization(metrics) # Physical Features
    print(json.dumps(metrics, indent=4))
    visualize_detections(metrics, input_img, output_img)
    metrics = feature_analysis(metrics) # Inter-Feature Distance
    with open("input.txt","a") as file:
        file.write("## Inter-Feature Distance\n")
        file.write(json.dumps(metrics,indent = 4)+ "\n")
    return metrics


if __name__=="__main__":
    """
    This file was not meant to be called directly from the cmd line.
    """
    print("Executing SAM API calling test to ensure connection and proper operation.")
    result = test_sam_service()