"""
author: Peter Xiao
email: peterxiaofun@gmail.com
date: 2024-12-15
"""

from openai import OpenAI
from PIL import Image
import json
import base64
import io
import numpy as np
import requests
from typing import List, Dict

from aigolfcaddie.constants import FORMATTED, SYSTEM_INSTRUCTIONS

"""
Contains all utility functions used by app.py to complete calls to SAM model and ChatGPT 4-o.
"""

api_key = 'REDACTED'
client = OpenAI(api_key=api_key)

SAM_API_ADDR = "https://clever-prompt-tiger.ngrok-free.app/sam/"

def get_samapi_version() -> str:
    """
    Return the samapi server package version. Also, can be used to check if server is connected.

    Returns:
        version_str: a string indiciating the SAM API version.
    """
    result = requests.get(SAM_API_ADDR + "version/")
    return result.text


def call_sam(b64str_img: str, bbox) -> str:
    """
    Utility function to call the SAM server at the SAM_API_ADDR. The SAM server will inference the
    SAM model to generate GeoJSON edges to capture segmented regions within the image.

    This function tunes the SAM parameters to work best with golf map segmentation. Specifically,
    this call makes a POST request to /sam/automask/ and waits for a response.

    The SAM parameters are described here:
        https://github.com/ksugar/samapi/tree/main?tab=readme-ov-file#endpoint-samautomask-post
    
    Args:
        b64str_img: an image encoded as an base64 character string.

    Returns:
        sam_segmentation: a geojson string that outlines the edges of the segmentations. The geojson
            contains a list of json objects with following keys: "geometry", "type", and
            "properties". 
    """
    # Note: Following https://github.com/ksugar/samapi/tree/main?tab=readme-ov-file#endpoint-samautomask-post
    result = requests.post(
        SAM_API_ADDR + "automask/",
        json={
            "type": "sam2_l",
            "b64img": b64str_img,
            "output_type": "Multi-mask (all)",
            "pred_iou_thresh": 0.8, # Default 0.88
            "points_per_side": 100, # Default 32
            "points_per_batch": 128, # Default 64
        }
    )
    return result.text


def calculate_center_of_mass(vertices):
    """
    Calculate the center of mass using the shoelace formula. 

    Args:
        verticies: a list of sequential verticies (u,v) describing a n-gon.
    
    Returns:
        com: the (u,v) of the center of mass of the shape.
    """
    n = len(vertices)
    
    area = 0.0
    cx = 0.0
    cy = 0.0

    # Calculate area using the shoelace formula
    for i in range(n):
        x0, y0 = vertices[i]
        x1, y1 = vertices[(i + 1) % n]  # Next vertex, wrapping around
        cross_product = x0 * y1 - x1 * y0
        area += cross_product
        cx += (x0 + x1) * cross_product
        cy += (y0 + y1) * cross_product
    
    area *= 0.5
    if area == 0:
        raise ValueError("The area of the polygon is zero, check the vertices.")
    
    # Finalize centroid coordinates
    cx /= (6 * area)
    cy /= (6 * area)

    return (round(cx,4), round(cy,4))


def analyze_result(geojson_str: str, clicks: Dict) -> List[Dict]:
    """
    Analyse geojson string generated by the samapi.

    Args:
        geojson_str: the geojson string. Contains a list of json objects with following keys: 
            "geometry", "type", and "properties". 

    Returns:
        bounding_boxes: a list of bounding boxes. Each bounding box is a dictionary with describing
            the locations of the box corners and center.
    """
    data = json.loads(geojson_str)
    all_metrics = []
    for golf_feature in clicks.keys():
        if golf_feature != "file" and golf_feature != "scale":
            for click in clicks[golf_feature]:
                minarea = -1
                click["u"] *= clicks["scale"]
                click["v"] *= clicks["scale"]
                for feature in data:  # feature contains 'type', 'geometry', and 'properties'
                    verticies = feature['geometry']['coordinates'][0]
                    verticies = np.array(verticies) * clicks["scale"]
                    
                    # Calculate the edges of the bounding box.
                    u0, v0 = np.min(verticies, axis=0)
                    u1, v1 = np.max(verticies, axis=0)
                    if contained(u0, v0, u1, v1, click):
                        if minarea == -1 or abs(u1 - u0) * abs(v1-v0) < minarea:
                            minarea = abs(u1 - u0) * abs(v1-v0)
                            feature_info = {
                                "feature_name" : golf_feature,
                                "feature_center_yards" : calculate_center_of_mass(verticies),
                                "coordinates" : [u0,v0,u1,v1]
                            } # add distance and direction to other features
                            if golf_feature == "tee":
                                feature_info["tee_color"] = click["color"]
                
                all_metrics.append(feature_info)
    return all_metrics


def contained(u0: float, v0: float, u1: float, v1: float, click: Dict) -> bool:
    """
    Determine whether a 2d click coordinate is located within a 2d bounding box.

    Args:
        u0: the u coordinate of the top left corner (u0,v0) of the bbox.
        v0: the v coordinate of the top left corner (u0,v0) of the bbox.
        u1: the u coordinate of the bot right corner (u1,v1) of the bbox.
        v1: the v coordinate of the bot right corner (u1,v1) of the bbox.
        click: the (u,v) coordinates of a specific point or "click"

    Returns:
        within: returns whether the click was within the bounding box described.
    """
    if u0 <= click["u"] and u1 >= click["u"] and v0 <= click["v"] and v1 >= click["v"]:
        return True
    else:
        return False


def setup_info():
    """
    Return information about the user's available clubs and expected performance.
    """
    setup_info = {
        "avilable_clubs" : ["driver", "7-iron", "5-hybrid", "5-iron", "sand wedge", "putter"],
        "club_performance" : {
            "driver" : 270, 
            "7-iron" : 140, 
            "5-hybrid" : 200, 
            "5-iron" : 160, 
            "pitching wedge": 90,
            "sand wedge" : 40,
        },
        "level_error" : 20,
        "tee_color" : "black"
    }
    return setup_info


def feature_organization(metrics: List[Dict]) -> Dict:
    """
    Organize golf features by their feature type based on their name

    Args:
        metrics: the golf features list. Contains a list of dictionaries each describing a golf 
            feature identified. The "feature_name" of each feature is 
            used to group features together by type

    Returns:
        features: a dictionary of golf features. The each key in the dictionary is a feature type, 
            with the value being a list containing all of the golf features of that feature type
    """
    features = {}
    for metric in metrics:
        try:
            features[metric["feature_name"]].append(metric)
        except:
            features[metric["feature_name"]] = [metric]
    return features
  

def get_gpt_response(message, image_path = None):
    """
    Call ChatGPT and get its response to user input using the OpenAI Python module

    Args:
        message: the text the user sent. This text is formatted using in accordance to what is laid out 
            in the system instructions for the model, containing three parts for setup information,
            physical features, and inter-feature distances
        image_path: the image of the golf map if provided. This image would be used as supplement for
            the model to use when identifying qualitative information such as the shape of the fairway.

    Returns:
        full_response: a string containing ChatGPT's response to the model. The response strictly follows
            the "formatted" JSON schema and contains the golf strategy information 
    """

    full_response = ""
    try:
        # Make an API call using the OpenAI module
        content = [
        {
            "type": "text",
            "text": message
        }
        ]
        if image_path:
            image = Image.open(image_path)
            image_bytes = io.BytesIO()
            image.save(image_bytes, format='PNG')
            image_bytes = (
                "data:image/png;base64," + base64.b64encode(image_bytes.getvalue()).decode()
            )
            content.append(
                {
                "type": "image_url",
                "image_url" :{
                    "url": image_bytes
                }
                }
            )
        for response in client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": SYSTEM_INSTRUCTIONS},
                {"role": "user", "content": content}
            ],
            stream=True,
            response_format = FORMATTED
        ):
            full_response += (response.choices[0].delta.content or "")
        # Extract the content of the response
        return full_response
    except Exception as e:
        return f"Error: {str(e)}"


def feature_analysis(metrics: Dict) -> List[Dict]:
    """
    Find the distance between golf features in yards

    Args:
        metrics: the golf features list. Contains a list of dictionaries each describing a golf feature 
            identified. The "feature_name" of each feature is used to group features together by type,
            used for the type vs type comparisons, and the "feature_center_yards" of each feature is
            used to find the distance between the two features.

    Returns:
        distances: a list of dictionaries about golf feature distances. Each dictionary contains the 
            distance between the two features, as well as the two dictionary descriptions of each
            golf feature. Comparisons were made between fairway and bunker, fairway and green,
            tee and fairway, and tee and bunker
    """
    # calculate distance from tee to middle of fairway, tee to bunker
    fairway_bunker = []
    fairway_green = []
    tee_fairway = []
    tee_bunker = []

    # lambda function to do distance calculations between two points
    def dist(feature1, feature2):
        x1, x2, y1, y2 = (
            feature1['feature_center_yards'][0],
            feature2["feature_center_yards"][0],
            feature1['feature_center_yards'][1],
            feature2["feature_center_yards"][1]
        )
        return round(((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5, 2)

    for fairway in metrics["fairway"]:
        for bunker in metrics["bunker"]:
            distance = dist(fairway, bunker)
            fairway_bunker.append({
                "distance" : distance,
                "feature_1" : fairway,
                "feature_2" : bunker
            })
        for green in metrics["green"]:
            distance = dist(fairway, green)
            fairway_green.append({
                "distance" : distance,
                "feature_1" : fairway,
                "feature_2" : green
            })
        for tee in metrics["tee"]:
            distance = dist(fairway, tee)
            tee_fairway.append({
                    "distance" : distance,
                    "feature_1" : tee,
                    "feature_2" : fairway
                })
    for tee in metrics["tee"]:
        for bunker in metrics["bunker"]:
            distance = dist(tee, bunker)
            tee_bunker.append({
                    "distance" : distance,
                    "feature_1" : tee,
                    "feature_2" : bunker
                })
    
    return fairway_bunker + fairway_green +tee_fairway + tee_bunker